
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Minesweeper game</title>
    <style>
      * {
        margin: 0px;
        padding: 0px;
        box-sizing: border-box;
        font-family: sans-serif;
      }

      body {
        text-align: center;
        background-color: powderblue;
        user-select: none;
      }

      body.defeat {
        background-color: rgb(240, 186, 157);
      }

      body.victory {
        background-color: rgb(158, 221, 143);
      }

      header,
      #message {
        margin-top: 50px;
      }

      #playfield {
        display: block;
        background: lightgrey;
        margin: auto;
        border: lightslategrey solid 1px;
        width: fit-content;
        margin-top: 50px;
        box-shadow: 0px 2px 6px rgb(0, 0, 0, 0.2);
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
      }

      .cell {
        display: inline-block;
        width: 40px;
        height: 40px;
        border: rgb(110, 113, 116) solid 1px;
        text-align: center;
        vertical-align: middle;
        font-size: 16px;
        line-height: 40px;
        font-weight: 900;
        cursor: pointer;
      }

      .cell:hover:not(.discovered) {
        background-color: rgb(232, 232, 232);
      }

      .discovered {
        background-color: rgb(177, 177, 177);
      }
    </style>
  </head>
  <body>
    <header>
      <span><b>Bombs count:</b> <span id="bombs-count">12</span></span>
      <span
        ><b>Cleared cells:</b> <span id="cleared-cells-count">0</span>/<span
          id="total-cells-to-clear"
          >100</span
        ></span
      >
    </header>

    <div id="playfield">
      <!-- This div will contain the cells. They will be generated by the "render" function. -->
    </div>

    <p id="message">Some message</p>

    <script>
      // Set this constant to true to debug the placement of bombs without
      // having to click on all cells to reveal them.
      const CHEAT_REVEAL_ALL = true

      const ROWS_COUNT = 10
      const COLS_COUNT = 10
      const BOMBS_COUNT = 10

      let defeat = false
      let victory = false

      // Cell constructor
      function Cell() {
        this.discovered = false
        this.isBomb = false
        this.hasBeenFlagged = false
      }

      // Initialize cells
      let cells = Array(ROWS_COUNT)
      for (let row = 0; row < ROWS_COUNT; row++) {
        cells[row] = Array(COLS_COUNT)
        for (let col = 0; col < COLS_COUNT; col++) {
          cells[row][col] = new Cell()
        }
      }

      //
      // DONE: Task 1 - add some bombs at fixed positions.

      cells[1][2].isBomb = true
      cells[0][1].isBomb = true
      cells[1][1].isBomb = true
      cells[3][1].isBomb = true
      cells[2][1].isBomb = true
      cells[5][1].isBomb = true
      cells[6][3].isBomb = true
      cells[8][2].isBomb = true
      cells[3][9].isBomb = true
      cells[9][7].isBomb = true
      cells[2][6].isBomb = true
      cells[6][5].isBomb = true

    
      //
/*       cells[1][2].isBomb =true;
      cells[0][2].isBomb =true;
      cells[1][4].isBomb =true;
      cells[7][2].isBomb =true;
      cells[1][8].isBomb =true;
      cells[6][2].isBomb =true;
      cells[1][9].isBomb =true;
      cells[2][2].isBomb =true;
      cells[7][7].isBomb =true;
      cells[5][7].isBomb =true;
      cells[6][3].isBomb =true;
      cells[9][0].isBomb =true; */

      
      //
      // DONE: Task 2 - Comment out the code of task 1. Instead of adding bombs in fixed places, add 10 of them in random places.
      //                Add a BOMBS_COUNT constant so that you can easily change the amount of bombs placed. Put it next to the
      //                other constants. 
      //

   
for (let i = 1; i <= BOMBS_COUNT; i++) {
    let ranRow = Math.floor(Math.random() * 10);
    let ranCol = Math.floor(Math.random() * 10);
    cells[ranRow][ranCol].isBomb = true;
}


      // Once the game has been initialized, we "render" it.
      render()

      //
      // Game functions definitions
      //

      function discoverCell(row, col) {
        //
        // DONE: Task 5 - Reveal cells when clicked.
        //
        cells[row][col].discovered = true;
        //
        // DONE: Task 6 - Discover neighbor cells recursively, as long as there are no adjacent bombs to the current cell.
        //

    for (let r = row; r < cells.length; r++) {
        for (let c = col; c < cells.length; c++) {
            cells[r][c].discovered = true;
            if (cells[r][c].isBomb) {
                cells[r][c].discovered = false;
                r = cells.length - 1;
                break;
            }
        }
    }
    for (let r = row; r >= 0; r--) {
        for (let c = col; c >= 0; c--) {
            cells[r][c].discovered = true;
            if (cells[r][c].isBomb) {
                cells[r][c].discovered = false;
                r = 0;
                break;
            }
        }
    }
        //
        // DONE: Task 8 - Implement defeat. If the player "discovers" a bomb (clicks on it without holding shift), set the variable defeat to true.
        //
        if (cells[row][col].isBomb) {
        defeat = true;
    }
      }

      function flagCell(row, col) {
        //
        // TODO: Task 7 - Implement flags. Flags allow the player to mark cells that they think contain a bomb.
        //                When clicking a cell and holding shift, function flagCell() will be called for you.
        //
      }

      // This function is called once for each cell when rendering the game. The row and col of the current cell is
      // passed to the functionn
      function countAdjacentBombs(row, col) {
        //
        // TODO: Task 4 - Adjacent bombs are bombs in cells touching our cell (also diagonally). Implement this function
        //                so that it returns the count of adjacent cells with bombs in them.
        //
        return 1
      }

      function getBombsCount() {
        //
        // TODO: Task 9 - Implement stats: the counters currently always display 0, calculate and return the relevant values.
        //
        return 0
      }

      function getClearedCells() {
        //
        // TODO: Task 9 - Implement stats: the counters currently always display 0, calculate and return the relevant values.
        //
        return 0
      }

      function getTotalCellsToClear() {
        //
        // TODO: Task 9 - Implement stats: the counters currently always display 0, calculate and return the relevant values.
        //
        return 0
      }

      function checkForVictory() {
        //
        // TODO: Task 10 - Implement victory. If the player has revealed as many cells as they must (every cell that isn't a
        //                 bomb), set variable victory to true.
        //
        return 0
      }

      //
      // Rendering functions
      //
      function getMessage() {
        if (victory == true) {
          return 'Well done! üëèüèº<br><br>Refresh the page to start again.'
        } else if (defeat) {
          return 'Boom! üí•<br><br>Refresh the page to try again.'
        }
        return ''
      }

      // "Render" the game. Update the content of the page to reflect any changes to the game state.
      function render() {
        const playfield = document.querySelector('#playfield')
        let html = ''
        for (let row = 0; row < ROWS_COUNT; row++) {
          html += '<div class="row">'
          for (let col = 0; col < COLS_COUNT; col++) {
            let cell = cells[row][col]
            let cellText = ''
            let cssClass = ''
            let textColor = ''
            if (cell.discovered || CHEAT_REVEAL_ALL || defeat) {
              cssClass = 'discovered'
              if (cell.isBomb) {
                cellText = 'üí£'
              } else {
                let adjBombs = countAdjacentBombs(row, col)
                if (adjBombs > 0) {
                  cellText = adjBombs.toString()
                  if (adjBombs == 1) {
                    textColor = 'blue'
                  } else if (adjBombs == 2) {
                    textColor = 'green'
                  } else if (adjBombs == 3) {
                    textColor = 'red'
                  } else if (adjBombs == 4) {
                    textColor = 'black'
                  }
                }
              }
            } else {
              if (cell.hasBeenFlagged) {
                cellText = 'üö©'
              }
            }
            html += `<div class="cell ${cssClass}" style="color:${textColor}" onclick="onCellClicked(${row}, ${col}, event)">${cellText}</div>`
          }
          html += '</div>'
        }
        playfield.innerHTML = html

        // Defeat screen
        const body = document.querySelector('body')
        if (defeat) {
          body.classList.add('defeat')
        }

        // Victory screen
        if (victory) {
          body.classList.add('victory')
        }

        // Update stats
        document.querySelector('#bombs-count').innerText =
          getBombsCount().toString()
        document.querySelector('#cleared-cells-count').innerText =
          getClearedCells().toString()
        document.querySelector('#total-cells-to-clear').innerText =
          getTotalCellsToClear().toString()

        // Update message
        document.querySelector('#message').innerHTML = getMessage()
      }

      // This function gets called each time a cell is clicked. Arguments "row" and "col" will be set to the relevant
      // values. Argument "event" is used to check if the shift key was held during the click.
      function onCellClicked(row, col, event) {
        if (event.shiftKey) {
          flagCell(row, col)
        } else {
          discoverCell(row, col)
        }
        checkForVictory()
        render()
      }
    </script>
  </body>
</html>
